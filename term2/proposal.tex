\chapter{Our Proposal: Framework Design}

We propose two major future versions of idock.

\section{idock 2.0: GPU Acceleration}

Even though idock 1.6 outperformed AutoDock Vina \citep{595} by at least 8.69 times and at most 37.51 times in terms of docking speed and was capable of docking 16 ligands per minute on a high performance machine, it is estimated to require about 312 days, i.e. nearly a year, to dock the complete 7,220,835 drug-like ligands from ZINC against a certain protein, not to mention multiple proteins. Virtual screening remains a time-consuming practice. Faster implementations are highly desired.

We used AMD CodeAnalyst Performance Analyzer v3.6 to detect program hotspots and observe thread behaviors. Figure \ref{idock:ThreadProfile} shows the thread profile of idock. Thread 1060 was the main thread, while the other four were workers threads spawned by the main thread and maintained by our novel thread pool. During program startup, the main thread parsed command line arguments, initialized necessary variables, parsed receptor file, and created a thread pool to precalculate the scoring function in parallel. Afterwards, it entered a loop, docking ligands one by one. The four workers threads actually carried out the creation of grid maps as well as running Monte Carlo tasks in parallel, fully occupying all the four CPU cores. Upon completion of docking a ligand, program control was returned to the main thread to write conformations to file and read the next ligand from file. From the figure, it can be concluded that the worker threads acquire most of the CPU computing resources and the precalculation of grid maps and the execution of Monte Carlo tasks constitute the program hotspots, albeit the CPU-intensive Monte Carlo tasks and the I/O-intensive file reading/writing can be possibly pipelined according to our in-house trial.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{idock/ThreadProfile.png}
\caption{idock thread profile.}
\label{idock:ThreadProfile}
\end{figure}

We propose idock 2.0, incorporating GPU acceleration with both CUDA and OpenCL, harnessing the tremendous computational power and memory bandwidth offered by modern GPUs nowadays. In \citeyear{1138} we developed a fast CUDA implementation of agrep algorithm for approximate nucleotide sequence matching \citep{1138}, demonstrating our expertise in CUDA programming. Meanwhile, we are eagerly learning OpenCL. We will first work on a CUDA version, followed by an OpenCL version.

Performance optimization revolves around three basic strategies: 1) maximizing parallel execution, 2) maximizing memory bandwidth, and 3) maximizing instruction throughput.

Maximizing parallel execution can be achieved by exposing as much data parallelism as possible and mapping the parallelism to the hardware as efficiently as possible. In dock, we have parallelized both the precalculation of grid maps and the Monte Carlo global optimization using our novel thread pool in order to thoroughly utilize multicore CPU. We plan to port these two most time-consuming parts to the GPU, map Monte Carlo tasks directly to CUDA threads, and use NVIDIA's occupancy calculator to carefully choose the execution configuration of each kernel launch in order to maintain a high GPU utilization. Several technical difficulties exist. One difficulty is the lack of sufficient capacity of GDDR5 memory, which is merely 2GB along with a GeForce GTX 680. This restriction voids the precalculation of grid maps at a fine granularity like 0.08\AA, leading to reduced approximation accuracy and possibly a high false negative rate. Another difficulty is the efficient generation of pseudo random numbers. Although there are official libraries and third-party libraries to facilitate this purpose, it is hard to determine the number of random numbers in need in advance because the Monte Carlo algorithm is stochastic \textit{per se}.

Maximizing memory bandwidth can be achieved by minimizing data transfers between the CPU and the GPU and optimizing the access patterns to global memory and shared memory on the GPU. Since CPU-to-GPU and GPU-to-CPU data transfers have much lower bandwidth than internal GPU data transfers, we plan to accommodate as much data as possible into the GPU global memory. In idock 2.0, constant data such as structure of receptor, definition of search space, precalculation of scoring function, and configurations for the BFGS Quasi-Newton local optimizer will reside in constant cache, while grid maps, due to its huge size, will reside in global memory, and temporary variables will reside in per-thread registers.

Maximizing global memory bandwidth is of crucial importance, and its bandwidth depends largely on its access pattern. Figure \ref{GPU:AlignedSequentialGlobalMemoryAccess} shows an example of aligned and sequential global memory access and corresponding memory transactions based on compute capability. In this case, 32 threads of a warp access adjacent 4-byte words such as adjacent single precision float values or 32-bit integer values. In other words, the \textit{k}th thread accesses the \textit{k}th 4-byte word in a 128B L1 cache line, a single coalesced transaction alone will service that memory access. In idock 2.0, we will adopt this kind of aligned and sequential access pattern and re-organize array of structures into structure of arrays, e.g.  [ \{ x1, y1, z1 \}, \{ x2, y2, z2 \} ] into \{ [ x1, x2 ], [ y1, y2 ], [ z1, z2 ] \}. Such a restructuring requires rewriting almost all the relevant mathematical data structures and functions in use in idock. So far we have stepped towards this direction a little bit, finishing rewriting the template class of quaternion from the BOOST C++ library into our own lightweight version to represent the orientation of a conformation.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{GPU/AlignedSequentialGlobalMemoryAccess.png}
\caption{Aligned and sequential global memory accesses by a warp, 4-byte word per thread, and associated memory transactions based on compute capability. Source: NVIDIA.}
\label{GPU:AlignedSequentialGlobalMemoryAccess}
\end{figure}

A GK104 SMX has 64KB of on-chip memory that can be configured as 48KB of shared memory with 16KB of L1 cache, or as 16KB of shared memory with 48KB of L1 cache. Since threads within a thread block run their Monte Carlo tasks independently and seldom communicate with one another, we decide to allocate 48KB of the 64KB on-chip memory to L1 cache.

Maximizing instruction throughput can be achieved by using single precision floating point instead of double precision and using intrinsics instead of regular functions. This strategy suggests trading precision for speed as long as the final result is not affected. Since most contemporary GPU chips supply with an astonishingly high throughput for single precision operations at TFLOP level but a relatively low throughput for double precision operations, we prefer the former. In order to make sure the precision loss must not affect the end result too much, we did an in-house trial, demoting double to float in idock, only to find that the predicted conformation and free energy were exactly identical as in the case of double precision given the same random seed for initializing the pseudo random number generator. This experiment concluded idock to be insensitive to precision switch and it is thus safe to utilize single precision operations as well as native intrinsics in idock 2.0.

By then with idock 2.0 at hand, we shall be able to perform proteomic-scale docking for the entire solved proteins in PDB \citep{540,537} and warehouse the huge results into a public database. We believe the community will definitely benefit from such a database with pre-docked information instantly available.

\section{idock 3.0: Ligand Synthesis}

Synthesis and docking are closely related. Figure \ref{igrow:SynthesisAndDocking} shows their recursive relationship. Tiny fragments are combined in accordance to chemistry rules to synthesize larger ligands, which are then docked to a receptor to evaluate their fitness. The best ligands enter the next iteration to synthesize other ligands, which are again evaluated by docking, until promising ligands are discovered. AutoGrow \citep{466}, released in \citeyear{466}, is a representative ligand synthesis tool that makes use of genetic algorithm and AutoDock Vina \citep{595} to automate this recursive synthesis/docking procedure.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{igrow/SynthesisAndDocking.png}
\caption{Iteratively synthesizing novel ligands from fragments followed by docking to a receptor.}
\label{igrow:SynthesisAndDocking}
\end{figure}

In 2011, inspired by AutoGrow, we developed SmartGrow, addressing several problems that AutoGrow suffers from. SmartGrow not only inherited the selection, mutation and crossover operators from AutoGrow, but also invented our novel merge and split operators. It implemented Lipinski's \textit{Rule of Five} \citep{168} to ensure drug likeness. Its robust parser correctly processed two-letter chemical elements like Cl (chlorine) and Br (bromine), and meanwhile added additional support for P (phosphorus), a common chemical element found in many drugs. Results showed that SmartGrow displayed comparable performance in terms of predicted free energy and meanwhile outperformed AutoGrow by 30\% in terms of execution time on average across 18 test cases. Besides, ligands generated by SmartGrow resulted in 100g/mol lower molecular weights than AutoGrow and never exceeded 500g/mol so that they can be absorbed by human body.

However, we wrote SmartGrow in a hurry and did not follow a formal software engineering approach. Later on when we conducted a benchmark on SmartGrow, we discovered a great many of exceptional bugs that were rather hard to track due to the messy code structure and lack of comments. Regretfully, we decided to abandon our buggy SmartGrow.

We then developed igrow as a successor of SmartGrow. Instead of porting existing code from SmartGrow and fixing bugs line by line, we rewrote igrow from scratch in a systematic manner. We borrowed several great ideas from idock, and deliberately designed igrow in the way that the output of idock directly feeds igrow as its input. Figure \ref{igrow:Flowchart} shows the flowchart of our current implementation of igrow. During initialization, igrow parses the initial elite ligands predicted by idock in a previous run, and scans a user-specified folder for fragments. Likewise in idock, igrow also creates a novel thread pool in order to parallelize the mutation and crossover operators and reuse threads throughout the entire synthesis procedure. Then igrow enters a loop, and utilizes genetic algorithm to iteratively synthesize novel ligands in parallel by either mutation or crossover, and invoke idock externally to predict free energy and select elite ligands by sorting the predicted free energy asendingly. So far we have implemented the initialization part as well as the selection and mutation operators. The crossover operator is yet to implement.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{igrow/Flowchart.pdf}
\caption{igrow flowchart.}
\label{igrow:Flowchart}
\end{figure}

Figure \ref{igrow:Mutation} illustrates the mutation operator in igrow. In the first generation, an elite ligand and a fragment are randomly selected and merged by removing a hydrogen atom from both sides and forming a new rotatable bond to connect both sides, thereby constructing an elite ligand in the second generation, which repeats the above steps until stopping criteria are satisfied. The mutation operator may produce novel ligands that display a higher binding affinity but may also suffer from a excessive molecular weight. Figure \ref{igrow:ProteinElitistsComplex} draws the three elitsts in complex with their target protein. It can be seen that due to the presence of additional fragments, the elite ligands may occupy significantly different binding conformations.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{igrow/Mutation.png}
\caption{igrow mutation operator.}
\label{igrow:Mutation}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{igrow/ProteinElitistsComplex.png}
\caption{Synthesized elitists by igrow in complex with their target protein.}
\label{igrow:ProteinElitistsComplex}
\end{figure}

Compared to AutoGrow and SmartGrow, our igrow features a plenty of advantageous innovations. From the perspective of input and output, igrow supports direct PDBQT manipulation, i.e. it digests ligands and fragments in PDBQT format and outputs ligands also in PDBQT format, saving the effort of frequently calling external python script for format conversion. igrow utilizes flyweight programming pattern to cache fragments and dynamic pointer vector to cache and sort ligands. From the perspective of CPU and memory utilization, igrow inherits from idock the highly efficient thread pool to parallelize the two genetic operators and maintain a high CPU utilization. igrow estimates the capacity of every vector structure and intensively utilizes right value reference, a new feature in the C++11 standard, to avoid frequent memory reallocation. From the perspective of functional improvements, in mutation, igrow supports halogen replacement as a new type of synthesis in addition to hydrogen replacement, and in crossover, igrow supports branch replacement, and in selection, igrow refreshes ligands with docked coordinates, potentially enabling partial docking as detailed below. igrow traces the sources of synthesized ligands and outputs statistics in CSV format for users to easily analyze how new ligands are synthesized from initial elite ligands and fragments. igrow allows users to specify ranges of several chemical properties, including molecular weight, number of atoms, number of heavy atoms, number of rotatable bonds, number of hydrogen bond donors and number of hydrogen bond acceptors, as validators for newly synthesized ligands. igrow is designed in a flexible way that it reserves room for adaptation to new molecular constraints. Instead of simply depending on the number of generations as a stopping criterion, igrow allows users to specify the number of validation failures as a more reasonable stopping criterion.

Clearly, there are two major problems with our current design. Problem one is the chemical infeasibility of ligands synthesized. This is a functional problem. Problem two is the high cost of invoking external idock in every generation. This is a computational problem.

Functionally speaking, ligands synthesized by our mutation and crossover operators, albeit chemically valid, might not be chemically synthesizable, simply because the two operators are somewhat arbitrary and do not conform to any known or general chemical reactions. In other words, that we can computationally synthesize novel ligands does not imply we can chemically synthesize them in reality. We may produce very fancy ligands at will, but all are just in computer simulation.

Computationally speaking, igrow relies on idock as its external docking engine and thus has to invoke idock every generation after synthesizing new ligands, repeatedly reading identical receptor and creating identical grid maps. Such duplications prolong program execution time quite a bit as the number of generations increases in genetic algorithm.

We propose idock 3.0 to address the above two problems. On one hand, inspired by AutoClickChem \citep{1051}, we plan to incorporate click chemistry into igrow to make sure every step of synthesis does follow some kind of well-known chemical reaction. On the other hand, we plan to integrate igrow into idock. In addition to receptor and grid map caching, another advantage of integration is the capability of partial docking, which refers to holding the main body of a ligand rigid while merely rotating newly added fragments. By cutting off the positional and orientational degrees of freedom, obviously partial docking can dramatically reduce search space dimensionality and therefore dramatically speed up the selection operator, which is the bottleneck of igrow.

idock 3.0 will also feature dual ligand docking (Figure \ref{igrow:2IQHDualLigands}), which refers to docking two ligands simultaneously inside one single large binding site. This feature is especially handy when the binding site is so large that it can accommodate more than one ligand. The existing scoring function shall be revised, properly merging individual scores into an overall one. The existing search algorithm shall also be revised to avoid possible steric clashes.
 
\begin{figure}
\centering
\includegraphics[width=\textwidth]{igrow/2IQHDualLigands.png}
\caption{Dual ligand docking.}
\label{igrow:2IQHDualLigands}
\end{figure}

As for software availability, igrow is free and open source under Apache License 2.0. It is written in C++ and available at https://github.com/HongjianLi/igrow. Precompiled executables for 32-bit and 64-bit Linux, Windows, Mac OS X, FreeBSD and Solaris are provided. Use cases and API documentations are also provided.

\chapterend
